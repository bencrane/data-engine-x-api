# Architecture

## Runtime Evolution: Execute -> Batch -> Entity State

The v1 system now runs a complete loop:

1. **Single operation execution** (`POST /api/v1/execute`) for canonical operation IDs.
2. **Batch orchestration** (`POST /api/v1/batch/submit`) that fan-outs entities into per-entity pipeline runs.
3. **Pipeline status aggregation** (`POST /api/v1/batch/status`) for submission-level progress and per-entity final context.
4. **Entity state accumulation** (`company_entities`, `person_entities`) after successful pipeline completion.
5. **Entity query surfaces** (`POST /api/v1/entities/companies`, `POST /api/v1/entities/persons`).

This is now implemented and active in the codebase.

## Why Trigger.dev Over Modal + Prefect

Trigger.dev is the execution runtime because this product is dominated by sequenced API operations, retries, and run traceability rather than long-lived compute containers.

Key reasons:

- Single runtime for orchestration and task execution.
- Native retry and run tracking primitives.
- Lower ops complexity than split orchestration/runtime stacks.
- Better fit for operation pipelines and callback-driven state updates.

## Why FastAPI Stays Python

FastAPI remains the tenancy and contract boundary:

- Auth verification and `AuthContext` construction.
- Tenant scoping (`org_id`, `company_id`, role checks).
- Request validation + persistence for submissions/runs/step results.
- Trigger.dev run triggering and externally visible status/entity endpoints.

FastAPI does not orchestrate step execution in-process; Trigger.dev does.

## Trigger.dev <-> FastAPI Bridge (Internal HTTP)

The runtime bridge is explicit HTTP with service auth:

1. FastAPI creates submission + pipeline runs + queued step rows.
2. FastAPI triggers Trigger task `run-pipeline` via Trigger API.
3. Trigger task calls FastAPI internal endpoints (`/api/internal/*`) using `DATA_ENGINE_INTERNAL_API_KEY`.
4. Trigger task runs operation steps via `POST /api/v1/execute` and passes:
   - `Authorization: Bearer <internal_api_key>`
   - `x-internal-org-id`
   - `x-internal-company-id`
5. FastAPI updates durable run state and entity state.

This keeps ownership clear:

- Python: tenancy, persistence, API contracts.
- TypeScript: ordered orchestration + retries + chaining.

## Output Chaining Model (Cumulative Context)

Pipeline step inputs are not isolated snapshots. They are chained:

- Initial context is entity input from `blueprint_snapshot.entity.input` (or submission input fallback).
- After each successful operation, `result.output` is merged into `cumulative_context`.
- The next step receives the merged cumulative context.
- Step outputs persist both operation result and cumulative context in `step_results.output_payload`.

This enables deterministic multi-step enrichment where downstream operations consume prior canonical outputs.

## Entity State Accumulation + Identity Resolution

On successful pipeline completion, Trigger calls `/api/internal/entity-state/upsert`:

- `entity_type=company` -> `upsert_company_entity(...)` -> `company_entities`
- `entity_type=person` -> `upsert_person_entity(...)` -> `person_entities`

Identity model:

- Primary identity key is `(org_id, entity_id)`.
- `entity_id` is taken from cumulative context when available, otherwise generated by entity-state services.
- Writes are versioned (`record_version`) and reject stale updates.
- Canonical columns + `canonical_payload` preserve both indexed and full payload forms.

## Multi-Tenancy Design

Primary hierarchy:

`Org -> Company -> User`

Execution hierarchy:

`Submission -> Pipeline Run -> Step Result`

Rules:

- Every tenant-owned query is scoped by `org_id`.
- Company-scoped reads/writes require `company_id` ownership under that org.
- Global step registry is shared; blueprints are org-scoped.

## Blueprint Snapshot Strategy

Blueprint definitions can change over time, but runs must remain immutable in meaning:

- Persist `blueprint_snapshot` on `pipeline_runs` at run creation.
- Persist deterministic `blueprint_version` derived from snapshot.
- Historical interpretation never depends on current blueprint rows.

## Auth Model

Two external auth methods, one runtime context:

- API tokens (machine auth, hashed at rest).
- JWT sessions (user auth, signature validated).

Internal service auth is additionally supported for Trigger callbacks/execution via `DATA_ENGINE_INTERNAL_API_KEY` plus internal org/company headers.

All paths resolve into `AuthContext` (`org_id`, `user_id`, `company_id`, `role`, `auth_method`).

## Legacy Model Note

The generic HTTP step executor model (`execute-step` task driven by `steps.url/method/auth_config/payload_template`) still exists for backward compatibility and migration safety.

Treat that model as **legacy** for new product work. Current v1 path uses operation-native `blueprint_steps.operation_id` executed through `/api/v1/execute` with canonical contracts and provider adapters.

## Failure and Cancellation Strategy

Default behavior is fail-fast:

- Any step failure marks pipeline run failed.
- Remaining queued steps are marked skipped.
- Submission status is synchronized from child run statuses.

Entity state upsert is part of completion criteria: if upsert fails, pipeline run is transitioned to failed.
